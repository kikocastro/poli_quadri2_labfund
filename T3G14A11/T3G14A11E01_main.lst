4000 0000 ; "DUMPER<"		;	DUMPER 		<
4001 0000 ; "DUMP_INI<"		;	DUMP_INI 	<
4002 0000 ; "DUMP_TAM<"		;	DUMP_TAM 	<
4003 0000 ; "DUMP_UL<"		;	DUMP_UL 	<
4004 0000 ; "DUMP_BL<"		;	DUMP_BL 	<
4005 0000 ; "DUMP_EXE<"		;	DUMP_EXE 	<
;
4006 0000 ; "LOADER<"		;	LOADER	  	<
4007 0000 ; "LOADER_UL<"		;	LOADER_UL 	<
;
4008 0000 ; "CHTOI<"		;	CHTOI		<
4009 0000 ; "INPUT_1_PTR<"		;	INPUT_1_PTR	<
4010 0000 ; "INPUT_2_PTR<"		;	INPUT_2_PTR	<
;
4011 0000 ; "GETDATA<"		;	GETDATA 	<
;
4012 0000 ; "CONST_0<"		;	CONST_0 	<
4013 0000 ; "CONST_1<"		;	CONST_1 	<
4014 0000 ; "CONST_2<"		;	CONST_2 	<
4015 0000 ; "CONST_C0<"		;	CONST_C0  <
4016 0000 ; "CONST_FF<"		;	CONST_FF 	<
4017 0000 ; "CONST_100<"		;	CONST_100 <
4018 0000 ; "CONST_300<"		;	CONST_300	<
4019 0000 ; "CONST_FFFC<"		;	CONST_FFFC	<
4020 0000 ; "CONST_FFFE<"		;	CONST_FFFE	<
4021 0000 ; "CONST_FFFF<"		;	CONST_FFFF	<
;
4022 0000 ; "WORD_BARS<"		;	WORD_BARS 		<
4023 0000 ; "WORD_BARS_END<"		;	WORD_BARS_END	<
4024 0000 ; "WORD_JB<"		;	WORD_JB			<
4025 0000 ; "WORD_DU<"		;	WORD_DU			<
4026 0000 ; "WORD_LO<"		;	WORD_LO			<
4027 0000 ; "WORD_EX<"		;	WORD_EX			<
4028 0000 ; "WORD_CL<"		;	WORD_CL			<
4029 0000 ; "OS_COMMAND<"		;	OS_COMMAND		<

4030 0000 ; "WORD_SPACES<"		;	WORD_SPACES		<
4031 0000 ; "WORD_EOL<"		;	WORD_EOL		<
4032 0000 ; "WORD_EOF<"		;	WORD_EOF 		<

4033 0000 ; "WRITE<"		;	WRITE 			<
4034 0000 ; "SUM<"		;	SUM 			<
4035 0000 ; "SUBTRACT<"		;	SUBTRACT		<
;
				;			& 	/0000
a000 0004		;	MAIN	JP 	INI		; salta para o início do programa
8002 0000		;	UL		K 	/0000 	; parâmetro: UL onde está o arquivo de batch
;
a004 a0ce		;	INI 		SC 	MAIN_RESET
			; Leitura de JB
a006 a110		;				SC 	READ_CMD
d008 5024		;				- 	WORD_JB
a00a 100e		;				JZ 	GET_CMD
a00c 00a6		;				JP	ERRO_JB
			; Leitura de DU, LO, EX, CL ou /* (final)
a00e a110		;	GET_CMD		SC 	READ_CMD
a010 10ac		;				JZ 	ERRO_CMD
d012 5025		;				-	WORD_DU
a014 107a		;				JZ 	GET_ARGS_DU
d016 4025		;				+ 	WORD_DU
d018 5026		;				-	WORD_LO
a01a 1082		;				JZ	GET_ARGS_LO
d01c 4026		;				+ 	WORD_LO
d01e 5027		;				- 	WORD_EX
a020 1096		;				JZ 	GET_ARGS_EX
d022 4027		;				+ 	WORD_EX
d024 5028		;				- 	WORD_CL
a026 1034		;				JZ 	GET_ARGS_CL
d028 4028		;				+ 	WORD_CL
d02a 5023		;				- 	WORD_BARS_END
a02c 10c4		;				JZ	DONE_OK
a02e 00b8		;				JP	ERRO_FIM
;
8030 0000		;	CL_NUMBER_OF_UL  K /0000
8032 0000		;	CL_INSTRUCTION  K /0000
			; le parametros de CL
a034 a214		;	GET_ARGS_CL SC  READ_ARGS_CL ; armazena as CL_UL e devolve o numero de ULs a serem apagadas
a036 10b2		;				JZ 	ERRO_ARG ; unico caso tratado: numero maximo de ULs: 15    --linha 36
d038 6017		;				* 	CONST_100 ; 2 shifts a esquerda para colocar o numero de ULs no terceiro byte
a03a 9030		;				MM  CL_NUMBER_OF_UL
a03c 3030		;				LV 	CL_NUMBER_OF_UL
d03e 4034		;				+ 	SUM
a040 9044		;				MM  CL_NUMBER
d042 8015		;				LD 	CONST_C0
8044 0000		;	CL_NUMBER	K   /0000 ; soma numero de unidades logicas a instrucao CL
a046 9032		;				MM 	CL_INSTRUCTION
a048 3032		;				LV  CL_INSTRUCTION
d04a 4034		;				+ 	SUM
a04c 9050		;				MM  CL_OS
d04e 8029		;				LD 	OS_COMMAND
8050 0000		;	CL_OS		K  	/0000 ; soma instrucao os
a052 9074		;				MM 	CL_CALL
a054 0074		;				JP  CL_CALL

			; enderecos reservados para CL
8056 0000		;				CL_UL15			K 		/0000
8058 0000		;				CL_UL14			K 		/0000
805a 0000		;				CL_UL13			K 		/0000
805c 0000		;				CL_UL12			K 		/0000
805e 0000		;				CL_UL11			K 		/0000
8060 0000		;				CL_UL10			K 		/0000
8062 0000		;				CL_UL9			K 		/0000
8064 0000		;				CL_UL8			K 		/0000
8066 0000		;				CL_UL7			K 		/0000
8068 0000		;				CL_UL6			K 		/0000
806a 0000		;				CL_UL5			K 		/0000
806c 0000		;				CL_UL4			K 		/0000
806e 0000		;				CL_UL3			K 		/0000
8070 0000		;				CL_UL2			K 		/0000
8072 0000		;				CL_UL1			K 		/0000

8074 0000		;	CL_CALL		K 	/0000 ; linha 74
a076 8212		;	LD ABCD
a078 000e		;				JP	GET_CMD

			; Leitura dos parametros de DU
a07a a18a		;	GET_ARGS_DU	SC 	READ_ARGS_DU
a07c 10b2		;				JZ	ERRO_ARG
d07e a000		;				SC	DUMPER
a080 000e		;				JP	GET_CMD
			; Leitura dos parametros de LO
a082 a1d0		;	GET_ARGS_LO	SC 	READ_ARGS_LO
a084 10b2		;				JZ	ERRO_ARG
d086 8007		;				LD 	LOADER_UL
d088 a006		;				SC	LOADER
			; O codigo abaixo deveria tratar os erros de LOAD (memoria insuficiente ou erro de checksum)
			; Todavia nao tratamos erros aqui, pois nos foi permitido assumir que as entradas estarao corretas
d08a 5020		;				-	CONST_FFFE
a08c 10a2		;				JZ	ERRO_LO_FFFE
d08e 4020		;	CONTINUE1	+	CONST_FFFE
d090 5019		;				-	CONST_FFFC
a092 10a4		;				JZ	ERRO_LO_FFFC
a094 000e		;	CONTINUE2	JP	GET_CMD
a096 a1ee		;	GET_ARGS_EX SC 	READ_ARGS_EX ; le e salva UL da imagem do programa a ser executado em LOADER_UL
d098 5021		;				- 	CONST_FFFF
a09a 10be		;				JZ 	ERRO_EX
d09c 4021		;				+ 	CONST_FFFF
			; chama loader para carregar imagem do programa na memoria
d09e a006		;				SC	LOADER ;			OS 	/00EF ; chama instrucao EX
a0a0 000e		;				JP 	GET_CMD
;
a0a2 008e		;	ERRO_LO_FFFE	JP	CONTINUE1 ; Houve erro do tipo FFFE (falta de memória disponível pra load)
a0a4 0094		;	ERRO_LO_FFFC	JP	CONTINUE2 ; Houve erro do tipo FFFC (checksum error) no Loader
;
80a6 3001		;	ERRO_JB		LV	/0001
80a8 f0ee		;				OS	/00EE
a0aa 00ca		;				JP	FIM
80ac 3002		;	ERRO_CMD	LV	/0002
80ae f0ee		;				OS 	/00EE
a0b0 00ca		;				JP	FIM
80b2 3003		;	ERRO_ARG	LV	/0003
80b4 f0ee		;				OS 	/00EE
a0b6 00ca		;				JP	FIM
80b8 3004		;	ERRO_FIM	LV	/0004
80ba f0ee		;				OS 	/00EE
a0bc 00ca		;				JP	FIM
80be 3005		;	ERRO_EX 	LV 	/0005
80c0 f0ee		;				OS 	/00EE
a0c2 00ca		;				JP 	FIM
80c4 3000		;	DONE_OK		LV	/0000
80c6 f0ee		;				OS	/00EE
a0c8 00ca		;				JP	FIM
a0ca c0ca		;	FIM 	 	HM	FIM		; fim do programa
;
; ###################################
; MAIN_RESET
; ###################################
;
; Reseta variaveis da main
;
80cc 0000		;	MAIN_READ_WORD 	K 	/0000
;
80ce 0000		;	MAIN_RESET 	K       /0000
a0d0 8002		;				LD      UL
d0d2 4018		;				+       CONST_300
d0d4 4011		;				+       GETDATA
a0d6 90cc		;				MM      MAIN_READ_WORD
a0d8 b0ce		;				RS 		MAIN_RESET
;
; ###################################
; GETWORD
; ###################################
;
; Escanea um par de caracteres ASCII, salvando-os no acumulador
;
80da 0000		;	GETWORD 	K       /0000
a0dc 80cc		;				LD      MAIN_READ_WORD
a0de 90e0		;				MM		GW_NEXT
80e0 0000		;	GW_NEXT		K 		/0000
a0e2 b0da		;				RS 		GETWORD
;
; ###################################
; GETPARAM
; ###################################
;
; Escanea dois pares de caracteres ASCII e os converte ao hexadecimal correspondente, salvando-o no acumulador
;
80e4 0000		;	GP_IN_1 	K		/0000
80e6 0000		;	GP_IN_2 	K		/0000
;
80e8 0000		;	GETPARAM 	K       /0000
a0ea a0da		;				SC 		GETWORD
d0ec 5031		;				- 		WORD_EOL
a0ee 110a		;				JZ 		GP_ERRO
d0f0 4031		;				+ 		WORD_EOL
d0f2 5032		;				-		WORD_EOF
a0f4 110a		;				JZ		GP_ERRO
d0f6 4032		;				+ 		WORD_EOF
a0f8 90e4		;				MM 		GP_IN_1
a0fa a0da		;				SC 		GETWORD
a0fc 90e6		;				MM 		GP_IN_2
;
a0fe 30e4		;				LV		GP_IN_1
d100 9009		;				MM 		INPUT_1_PTR
a102 30e6		;				LV		GP_IN_2
d104 9010		;				MM 		INPUT_2_PTR
d106 a008		;				SC 		CHTOI
a108 010c		;				JP		GP_END
; GP_ERRO 	LD 		CONST_FFFF ; FFFF pode ser retorno do parametro EXE (instr. executavel) do DUMPER
a10a b0e8		;	GP_ERRO 	RS 		GETPARAM
a10c b0e8		;	GP_END		RS 		GETPARAM
;
; ###################################
; READ_CMD
; ###################################
;
; Le uma.
; Retorna WORD_JB se leu //JB <EOL>
; Retorna WORD_DU se leu //DU <EOL>
; Retorna WORD_LO se leu //LO <EOL>
; Retorna WORD_EX se leu //EX <EOL>
; Retorna WORD_BARS_END se leu /* <EOF>
; Retorna 0 se houve erro de job ou comando
; Retorna 1 se houve erro de fim
;
810e 0000		;	ANS			K 		/0000 ; Valor de retorno da sub-rotina
;
8110 0000		;	READ_CMD	K       /0000
a112 a0da		;				SC		GETWORD
d114 5022		;				-		WORD_BARS
a116 1120		;				JZ		RC_BARS ; Escaneou o "//"
d118 4022		;				+ 		WORD_BARS
d11a 5023		;				- 		WORD_BARS_END
a11c 1140		;				JZ		RC_BARS_END ; Escaneou o "/*"
a11e 0184		;				JP		RC_ERRO_FIM
a120 a0da		;	RC_BARS		SC 		GETWORD
d122 5024		;				-		WORD_JB
a124 1152		;				JZ 		RC_JB ;	Escaneou o "//JB"
d126 4024		;				+ 		WORD_JB
d128 5025		;				- 		WORD_DU
a12a 1158		;				JZ		RC_DU ; Escaneou o "//DU"
d12c 4025		;				+ 		WORD_DU
d12e 5026		;				- 		WORD_LO
a130 115e		;				JZ 		RC_LO ; Escaneou o "//LO"
d132 4026		;				+		WORD_LO
d134 5027		;				-		WORD_EX
a136 1164		;				JZ 		RC_EX ; Escaneou o "//EX"
d138 4027		;				+ 		WORD_EX
d13a 5028		;				- 		WORD_CL
a13c 116a		;				JZ 		RC_CL ; escaneou "//CL"
a13e 0180		;				JP		RC_ERRO_CMD
a140 a0da		;	RC_BARS_END	SC 		GETWORD
d142 5032		;				- 		WORD_EOF
a144 117c		;				JZ 		RC_OK_FIM ; Escaneou o "/* <EOF>"
d146 4032		;				+ 		WORD_EOF
d148 5031		;				- 		WORD_EOL
a14a a0da		;				SC 		GETWORD
d14c 5032		;				-		WORD_EOF
a14e 117c		;				JZ 		RC_OK_FIM ; Escaneou o "/* <EOL> <EOF>"
a150 0184		;				JP 		RC_ERRO_FIM
;
d152 8024		;	RC_JB		LD 		WORD_JB
a154 910e		;				MM		ANS
a156 0170		;				JP 		RC_GET_EOL
d158 8025		;	RC_DU		LD 		WORD_DU
a15a 910e		;				MM		ANS
a15c 0170		;				JP		RC_GET_EOL
d15e 8026		;	RC_LO		LD		WORD_LO
a160 910e		;				MM		ANS
a162 0170		;				JP		RC_GET_EOL
d164 8027		;	RC_EX		LD 		WORD_EX
a166 910e		;				MM		ANS
a168 0170		;				JP		RC_GET_EOL
d16a 8028		;	RC_CL		LD 		WORD_CL
a16c 910e		;				MM		ANS
a16e 0170		;				JP		RC_GET_EOL
;
a170 a0da		;	RC_GET_EOL	SC 		GETWORD
d172 5031		;				- 		WORD_EOL
a174 1178		;				JZ		RC_OK_CMD
a176 0180		;				JP		RC_ERRO_CMD
;
a178 810e		;	RC_OK_CMD	LD 		ANS
a17a 0188		;				JP 		RC_END
d17c 8023		;	RC_OK_FIM	LD 		WORD_BARS_END
a17e 0188		;				JP		RC_END
8180 3000		;	RC_ERRO_CMD	LV 		/0000
a182 0188		;				JP 		RC_END
8184 3001		;	RC_ERRO_FIM	LV 		/0001
a186 0188		;				JP		RC_END
a188 b110		;	RC_END 		RS 		READ_CMD
;
;
; ###################################
; READ_ARGS_DU
; ###################################
;
; Le a para um comando DUMP
; e os armazena nas posicoes de memoria correspondentes (DUMP_BL, DUMP_INI, DUMP_TAM, DUMP_EXE, DUMP_UL)
; Retorna 0 em caso de erro, 1 caso contrario
;
818a 0000		;	READ_ARGS_DU	K       /0000
a18c a0e8		;	RAD_BL		SC		GETPARAM
			; - 		CONST_FFFF
			; JZ		RAD_ERRO
			; + 		CONST_FFFF
d18e 9004		;				MM 		DUMP_BL
a190 a0da		;				SC		GETWORD
d192 5030		;				- 		WORD_SPACES
a194 1198		;				JZ		RAD_INI
a196 01c8		;				JP 		RAD_ERRO
;
a198 a0e8		;	RAD_INI		SC		GETPARAM
			; - 		CONST_FFFF
			; JZ		RAD_ERRO
			; + 		CONST_FFFF
d19a 9001		;				MM 		DUMP_INI
a19c a0da		;				SC		GETWORD
d19e 5030		;				- 		WORD_SPACES
a1a0 11a4		;				JZ		RAD_TAM
a1a2 01c8		;				JP 		RAD_ERRO
;
a1a4 a0e8		;	RAD_TAM		SC		GETPARAM
			; - 		CONST_FFFF
			; JZ		RAD_ERRO
			; + 		CONST_FFFF
d1a6 9002		;				MM 		DUMP_TAM
a1a8 a0da		;				SC		GETWORD
d1aa 5030		;				- 		WORD_SPACES
a1ac 11b0		;				JZ		RAD_EXE
a1ae 01c8		;				JP 		RAD_ERRO
a1b0 a0e8		;	RAD_EXE		SC		GETPARAM
			; - 		CONST_FFFF
			; JZ		RAD_ERRO
			; + 		CONST_FFFF
d1b2 9005		;				MM 		DUMP_EXE
a1b4 a0da		;				SC		GETWORD
d1b6 5030		;				- 		WORD_SPACES
a1b8 11bc		;				JZ		RAD_UL
a1ba 01c8		;				JP 		RAD_ERRO
a1bc a0e8		;	RAD_UL		SC		GETPARAM
			; - 		CONST_FFFF
			; JZ		RAD_ERRO
			; + 		CONST_FFFF
d1be 9003		;				MM 		DUMP_UL
a1c0 a0da		;				SC 		GETWORD ; BUG AQUI ?
d1c2 5031		;				-		WORD_EOL
a1c4 11cc		;				JZ		RAD_DONE_OK
a1c6 01c8		;				JP		RAD_ERRO
;
81c8 3000		;	RAD_ERRO	LV		/0000
a1ca 01ce		;				JP 		RAD_END
81cc 3001		;	RAD_DONE_OK	LV 		/0001
a1ce b18a		;	RAD_END		RS 		READ_ARGS_DU
;
; ###################################
; READ_ARGS_LO
; ###################################
;
; Le a para um comando LOAD
; Retorna 0 em caso de erro, 1 caso contrario
;
81d0 0000		;	READ_ARGS_LO	K       /0000
a1d2 a0e8		;				SC		GETPARAM
d1d4 5021		;				- 		CONST_FFFF
a1d6 11e4		;				JZ		RAL_ERRO
d1d8 4021		;				+ 		CONST_FFFF
d1da 9007		;				MM 		LOADER_UL
a1dc a0da		;				SC		GETWORD
d1de 5031		;				- 		WORD_EOL
a1e0 11e8		;				JZ		RAL_DONE_OK
a1e2 01e4		;				JP 		RAL_ERRO
;
81e4 3000		;	RAL_ERRO	LV		/0000
a1e6 01ea		;				JP 		RAL_END
81e8 3001		;	RAL_DONE_OK	LV 		/0001
a1ea b1d0		;	RAL_END		RS 		READ_ARGS_LO
;
;
; ###################################
; READ_ARGS_EX
; ###################################
;
; Le a para um comando EX
; Retorna o valor do (único) parametro de EX FFFF ou FFFF em caso de erro
;
81ec 0000		;	EX_ADDRESS		K 		/0000
;
81ee 0000		;	READ_ARGS_EX	K       /0000
a1f0 a0e8		;				SC		GETPARAM
a1f2 91ec		;				MM 		EX_ADDRESS
			; para EX_ADDRESS ser valido precisa estar entre 0000 e 00FF, senão raise erro FFFF
d1f4 8016		;				LD 		CONST_FF
a1f6 51ec		;				- 		EX_ADDRESS
a1f8 2206		;				JN 		RAE_ERRO
a1fa 81ec		;				LD 		EX_ADDRESS
d1fc 9007		;				MM 		LOADER_UL
a1fe a0da		;				SC		GETWORD
d200 5031		;				- 		WORD_EOL
a202 120a		;				JZ		RAE_DONE_OK
a204 0206		;				JP 		RAE_ERRO
;
d206 8021		;	RAE_ERRO	LD 		CONST_FFFF
a208 020c		;				JP 		RAE_END
a20a 81ec		;	RAE_DONE_OK	LD 		EX_ADDRESS
a20c b1ee		;	RAE_END		RS 		READ_ARGS_EX
;
;
;
; ###################################
; READ_ARGS_CL
; ###################################
;
; Le a para um comando CL
; Retorna 0 em caso de sucesso ou FFFF em caso de erro
; nao foram tratados erros de UL fora do range 0-FF e numero de ULs fora do range 0-15
;
;
820e 0000		;	RACL_COUNTER 			K 		/0000
8210 0000		;	RACL_CURR_ADDR 			K 		/0000
8212 abcd		;	ABCD K /ABCD
;
8214 0000		;	READ_ARGS_CL			K       /0000
a216 3072		;							LV 		CL_UL1
a218 9210		;							MM 		RACL_CURR_ADDR ; endereco da primeira UL

						; ******** LOOP *********
a21a 8210		;	RACL_LOOP				LD 		RACL_CURR_ADDR
d21c 4033		;							+ 		WRITE
a21e 9222		;							MM 		RACL_STORE
a220 a0e8		;							SC		GETPARAM ; carega numero da UL
8222 0000		;	RACL_STORE 				K 		/0000 ; armazena numero da UL nos parametros de CL     ;linha 212

						; atualiza contador
d224 3013		;							LV 		CONST_1
d226 4034		;							+ 		SUM
a228 922c		;							MM 		RACL_UPDATE_COUNTER
a22a 820e		;							LD 		RACL_COUNTER
822c 0000		;	RACL_UPDATE_COUNTER		K 		/0000
a22e 920e		;							MM 		RACL_COUNTER

						; atualiza endereco atual
d230 3014		;							LV 		CONST_2
d232 4035		;							+ 		SUBTRACT
a234 9238		;							MM 		RACL_UPDATE_CURR_ADDR
a236 8210		;							LD 		RACL_CURR_ADDR
8238 0000		;	RACL_UPDATE_CURR_ADDR	K 		/0000
a23a 9210		;							MM 		RACL_CURR_ADDR

						; verifica se e EOL
a23c a0da		;							SC 		GETWORD ;linha 22e
d23e 5031		;							- 		WORD_EOL
a240 124e		;							JZ 		RACL_END_OK
d242 4031		;							+ 		WORD_EOL

						; verifica se tem dois espacos
d244 5030		;							- 		WORD_SPACES
a246 121a		;							JZ 		RACL_LOOP
a248 024a		;							JP 		RACL_ERROR

						; ******** END LOOP *********
d24a 8021		;	RACL_ERROR 				LD 		CONST_FFFF
a24c 0250		;							JP 		RACL_END

a24e 820e		;	RACL_END_OK 			LD 		RACL_COUNTER  ; linha 23e

a250 b214		;	RACL_END				RS 		READ_ARGS_CL
;
